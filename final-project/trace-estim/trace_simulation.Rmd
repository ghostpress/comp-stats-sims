---
title: "Simulations for Trace Estimation by Sampling"
author: "Lucia Vilallonga"
output: html_notebook
---

## Set Up
```{r}
library(ggplot2)
```

## Methods
```{r}
# A method to compute an unbiased estimator for the trace of a psd matrix. 
# The method uses a random isotropic test vector and matrix-vector 
# multiplication to produce the estimator for the trace. 
# Recall that:
#  * the trace of a square matrix is the sum of its diagonal elements
#  * an unbiased estimator has an expected value equal to the quantity to be estimated
#  * an isotropic vector w is one with the property E[w %*% t(w)] = I
# For proof that this method does produce an unbiased estimator for the trace of a psd
# matrix, please see the accompanying proofs.pdf file.
#
# Parameters
# ----------
# A :  matrix()
#      The nxn psd matrix for which to estimate the trace
# k :  integer
#      The number of samples to take
#
# Returns
# -------
# values$X :  double
#             The estimate of trace(A)
# values$S :  double
#             The sample variance of the estimate
#
traceEstimate <- function(A, k) {
  assertthat::is.count(k)
  
  samples <- matrix(0, nrow=k, ncol=1)
  
  for(i in 1:k) {
    # Draw the isotropic test vector, eg. from the Gaussian distr. with variance=1
    test_vector <- matrix(rnorm(n, mean=0, sd=1), nrow=n, ncol=1)  
    
    # Compute the sample of the estimate and add it to the list
    sample <- t(test_vector) %*% (A %*% test_vector)
    samples[i] <- sample
  }
  
  estimate <- (1/k) * sum(samples)                     # compute the estimate
  var      <- (1/(k-1)) * sum((samples - estimate)^2)  # compute the variance
  
  return(list("X" = estimate, "S" = var))
}
```

```{r}
# A method to compute the true trace of a matrix, for comparison with the RandNLA method.
#
# Parameters
# ----------
# A :  matrix()
#      The nxn psd matrix for which to compute the trace
#
# Returns
# -------
# tr : double
#      The trace of the input matrix
#
trace <- function(A) {
  n <- nrow(A)
  tr <- 0
  
  for(i in 1:n) {
    tr <- tr + A[i,i]
  }
  
  return(tr)
}
```

```{r}
# A method to compute the error of the estimate as compared to the true value.
# 
# Parameters
# ----------
# a,b  :  list 
#         The two lists to compare
# 
# Returns
# -------
# errs :  list
#         The absolute errors for each element in the lists ($abs), 
#         the mean error ($avg),  
#         and the mean squared error ($mse)
#
compute_err <- function(a, b) {
  
  abs <- matrix(0, nrow=1, ncol=length(a))
  avg <- 0
  rms <- 0
  
  # Compute the absolute error
  for(i in 1:length(a)) {
    abs[i] <- abs(a[[i]] - b[[i]])
  }
  
  # Compute the mean error
  sum <- sum(abs)
  avg <- sum / length(a)
  
  # Compute the root mean squared error (RMSE)
  for(i in 1:length(a)) {
    rms[i] <- sqrt((a[[i]] - b[[i]])^2) / length(a)
  }
  
  return(list("abs" = abs, "avg" = avg, "rms" = rms))
}
```

## Simulation: Is the Estimate Faster? How Accurate is it?
```{r}
set.seed(987654321)

N <- seq(from=1, to=101, by=5)
K <- seq(from=1, to=101, by=5)

trace_true_list   <- vector(mode="list", length=length(N))
runtime_true_list <- vector(mode="list", length=length(N))

trace_est_list    <- vector(mode="list", length=length(N) + length(K))
runtime_est_list  <- vector(mode="list", length=length(N) + length(K))
variance_list     <- vector(mode="list", length=length(N) + length(K))
stddev_list       <- vector(mode="list", length=length(N) + length(K))

index_true <- 1
index_est  <- 1

for(n in N) {
  # Generate a random psd matrix for the simulation
  A <- matrix(rnorm(n*n), nrow=n, ncol=n)
  A <- A %*% t(A)
  
  # Compute the true trace and record the runtime
  start <- Sys.time()
  
  trace_true <- trace(A)
  runtime_true_list[index_true] <- Sys.time() - start
  
  trace_true_list[index_true] <- trace_true
  
  index_true <- index_true + 1
  
  for(k in K) {
    # Compute the estimate of the trace and record the runtime
    new_start <- Sys.time()
  
    trace_est  <- traceEstimate(A, 100)
    runtime_est_list[index_est] <- Sys.time() - new_start

    trace_est_list[index_est] <- trace_est$X
    variance_list[index_est]  <- trace_est$S
    stddev_list[index_est]    <- sqrt(as.double(trace_est$S))
  
    index_est <- index_est + 1
  }
}

# Compute the errors
abs_err <- compute_err(trace_est_list, trace_true_list)$abs
avg_err <- compute_err(trace_est_list, trace_true_list)$avg
rms_err <- compute_err(trace_est_list, trace_true_list)$rms
```

## Plotting the Results
```{r}
# Create a data frame with the results
results <- data.frame(matrix(ncol=5, nrow=length(N) + length(K)))
colnames(results) <- c("n (rows)", "k (samples)", "Estimate", "True Value", "RMSE")

# Basic plots

ggplot(err_data, aes(x=N, y=abs_err)) +
  geom_point(size=1, color="#316c9f") +
  geom_point(aes(x=N, y=rms_err), size=1, color="#a00058") +
  geom_abline(intercept=avg_err, slope=0) +
  ggtitle("Errors in Trace Estimation for k=30") +
  ylab("Magnitude") +
  xlab("N (number of rows)")

ggplot(err_data, aes(x=abs_err)) +
  geom_histogram()

# plot run times

ggplot(run_data, aes(x=N, y=runtime_est_list)) +
  geom_point(size=1)
```
