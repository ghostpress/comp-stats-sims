---
title: "Simulations for Norm Estimation by Sampling"
author: "Lucia Vilallonga"
output: html_notebook
---

## Set Up
```{r}
library(psych)  # for the trace method
```

## Methods
```{r}
# A method to draw a random test matrix with isotropic column vectors.
# Recall that:
#  * an isotropic vector w is one with the property E[w %*% t(w)] = I
#
# Parameters
# ----------
# n :  int
#      The number of rows
# k :  int
#      The number of columns
#
# Returns
# -------
# O :  matrix()
#      The test matrix
#
drawTestM <- function(n, k) {
  
  O <- NULL # matrix(0, nrow=n, ncol=k)
  
  for(i in (1:k)) {
    # Draw an isotropic column vector, eg. from the Gaussian distr. with variance=1
    col <- matrix(rnorm(n, mean=0, sd=1), nrow=n, ncol=1)
    O <- cbind(O, col)
  }
  
  return(O)
}
```

```{r}
# A method to compute the true (l-2p)^2p norm of a matrix, to compare with the estimate.
#
# Parameters
# ----------
# A :  matrix()
#      The nxm matrix for which to compute the norm
#
# Returns
# -------
# nrm : double
#       The (l-2p)^2p norm of the input matrix   
#
computeNorm <- function(A, p) {
  n <- nrow(A)
  m <- ncol(A)
  
  nrm <- 0
  innersum <- 0
  
  for(j in (1:m)) {
    for(i in (1:n)) {
      innersum <- sum( abs(A[i,j])^(2*p) )
    }
    nrm <- nrm + innersum^(1/(2*p))
  }
  
  return(nrm^(2*p))
}

# FIXME: incorrect value
```

```{r}
# A method to compute an unbiased estimator for the l-2p norm of a matrix.
# The method uses: a random test matrix (see drawTestM()); matrix-vector multiplication; 
# and a linear map from the space of self-adjoint square matrices to 
# the space of general square upper triangular matrices.
# Recall that:
#  * the l-2p norm of a matrix is the 2p-root sum of its elements^2p
#  * an unbiased estimator has an expected value equal to the quantity to be estimated
#  * an isotropic vector w is one with the property E[w %*% t(w)] = I
# For proof that this method does produce an unbiased estimator for the l-2p norm of a
# matrix, please see the accompanying proofs.pdf file.
#
# Parameters
# ----------
# B :  matrix()
#      The mxn matrix for which to estimate the l-2p norm
# p :  int
#      The power >0 of the norm
# k :  int
#      The number of samples to take
#
# Returns
# -------
# V : double
#     The estimate of the l-2p norm
#
schattenEstimate <- function(B, p, k) {
  m <- nrow(B)
  n <- ncol(B)
  
  O <- drawTestM(n, k)  # draw the test matrix (nxk)
  Y <- B %*% O          # compute the sample matrix (mxk)
  X <- t(Y) %*% Y       # compute the Gram matrix (kxk)   

  # Extract the strict upper triangle of X  
  T_p <- X
  T_p[lower.tri(T_p)] <- 0
  diag(T_p) <- 0
  
  # Compute T^(p-1) by repeated multiplication
  if(p > 1) {
    for(i in (1:p-1)) {
      T_p <- T_p %*% T_p
    }
  } else if(p == 1) {
    T_p <- matrix(1, nrow=k, ncol=k)
  }
  
  # Compute and return the estimate of the norm
  V <- (1/choose(k, p))  * tr(T_p %*% X) 
  return(V)
}
```

## Testing
```{r}


A <- matrix(rnorm(10*10, mean=0, sd=1), nrow=10, ncol=10)
x <- schattenEstimate(A, 1, 10)  # compute the 2p = l2 norm of B
#computeNorm(B, 1)               # test with Frobenius norm
(norm(B, type="F"))



```

## Simulation

## Plot the Results
```{r}
# TODO: 
#   plot runtime vs k vs p
#   plot errors vs k vs p
```